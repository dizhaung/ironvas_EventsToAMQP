/*
 * #%L
 * =====================================================
 *   _____                _     ____  _   _       _   _
 *  |_   _|_ __ _   _ ___| |_  / __ \| | | | ___ | | | |
 *    | | | '__| | | / __| __|/ / _` | |_| |/ __|| |_| |
 *    | | | |  | |_| \__ \ |_| | (_| |  _  |\__ \|  _  |
 *    |_| |_|   \__,_|___/\__|\ \__,_|_| |_||___/|_| |_|
 *                             \____/
 * 
 * =====================================================
 * 
 * Hochschule Hannover
 * (University of Applied Sciences and Arts, Hannover)
 * Faculty IV, Dept. of Computer Science
 * Ricklinger Stadtweg 118, 30459 Hannover, Germany
 * 
 * Email: trust@f4-i.fh-hannover.de
 * Website: http://trust.f4.hs-hannover.de
 * 
 * This file is part of ironvas, version 0.1.7, implemented by the Trust@HsH
 * research group at the Hochschule Hannover.
 * %%
 * Copyright (C) 2011 - 2016 Trust@HsH
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package de.hshannover.f4.trust.ironvas.omp

import java.util.logging.Logger
import scala.collection.JavaConversions.seqAsJavaList
import scala.collection.mutable.HashSet
import de.hshannover.f4.trust.ironvas.Report
import de.hshannover.f4.trust.ironvas.VulnerabilityHandler
import de.hshannover.f4.trust.ironvas.VulnerabilityFilter
import de.hshannover.f4.trust.ironvas.Vulnerability
import de.hshannover.f4.trust.ironvas.AmqpPublisher

object PassThroughFilter extends VulnerabilityFilter {
  override def filter(v: Vulnerability) = true
}

/**
 * A <code>VulnerabilityFetcher</code> is responsible for periodically getting
 * scan reports from on OpenVAS server.
 *
 * @author Ralf Steuerwald
 *
 * @constructor creates a new <code>VulnerabilityFetcher</code>
 * @param handler  the <code>VulnerabilityHandler</code> which is responsible
 *                 for processing the vulnerabilities
 * @param omp      the <code>OmpConnection</code> used for executing OMP requests
 * @param interval the time to wait between two fetch operations in seconds
 * @param filter   a VulnerabilityFilter which is used to filter the incoming
 *                 scan results
 */
class VulnerabilityFetcher(
  handler: VulnerabilityHandler,
  omp: OmpConnection,
  interval: Int,
  amqpPub: AmqpPublisher,
  filter: VulnerabilityFilter) extends Runnable {

  private val logger = Logger.getLogger(getClass().getName())

  private val seenTasks = new HashSet[Task]

  /**
   * Creates a new <code>VulnerabilityFetcher with the given parameter and
   * a <code>VulnerabilityFilter</code> which is going to let all vulnerability
   * pass.
   */
  def this(handler: VulnerabilityHandler, omp: OmpConnection, interval: Int, amqpPub: AmqpPublisher) = {
    this(handler, omp, interval, amqpPub, PassThroughFilter)
  }

  /**
   * Run the fetch loop. The following steps are performed:
   *
   * 1. Get the latest reports of all tasks from the OpenVAS server.
   * 2. For every latest report:
   *    2.1. Get all vulnerabilities of that report from the OpenVAS server.
   *    2.2. Send the list of vulnerabilities to the VulnerabilityHandler
   * 3. Sleep a given interval.
   * 4. Start at 1. again.
   */
  override def run(): Unit = {
    logger.info("starting " + getClass().getSimpleName())

    try {
      while (!Thread.currentThread().isInterrupted()) {
        val (_, currentTasks) = omp.getTasks()
        val deletedTasks = seenTasks diff currentTasks.toSet

        if (deletedTasks.size > 0) {
          logger.fine("tasks %s not longer present on the openvas server".format(deletedTasks))

          for (task <- deletedTasks) {
            val emptyReport = new Report(task.id, seqAsJavaList(Nil))
            handler.submit(emptyReport)
            
            if(amqpPub != null){
              amqpPub.submit(emptyReport)
            }

            seenTasks -= task
          }
        }

        val latestReports = omp.getLatestReports()
        logger.fine("found " + latestReports.length + " reports")

        for ((task, vulnerabilities) <- latestReports) {
          val filtered = vulnerabilities.filter(filter.filter(_))
          val lastReport = new Report(task.id, seqAsJavaList(filtered))
          handler submit lastReport
          
          if(amqpPub != null){
            amqpPub.submit(lastReport)
          }
          
          seenTasks += task
        }

        Thread.sleep(interval * 1000)
      }
    } catch {
      case e: InterruptedException => {
        Thread.currentThread().interrupt();
        logger.info("wakup by interrupt signal, exiting ...")
      }
    } finally {
      logger.info("shutdown complete.")
    }
  }
}
